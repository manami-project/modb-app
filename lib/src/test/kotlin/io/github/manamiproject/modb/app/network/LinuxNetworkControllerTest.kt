package io.github.manamiproject.modb.app.network

import io.github.manamiproject.kommand.CommandExecutor
import io.github.manamiproject.kommand.CommandLineConfig
import io.github.manamiproject.modb.app.TestAppConfig
import io.github.manamiproject.modb.app.TestCommandExecutor
import io.github.manamiproject.modb.app.config.Config
import io.github.manamiproject.modb.core.extensions.EMPTY
import io.github.manamiproject.modb.core.extensions.containsExactlyInTheSameOrder
import io.github.manamiproject.modb.test.exceptionExpected
import io.github.manamiproject.modb.test.loadTestResource
import io.github.manamiproject.modb.test.shouldNotBeInvoked
import io.github.manamiproject.modb.test.tempDirectory
import kotlinx.coroutines.*
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Nested
import java.time.Clock
import java.time.Instant
import java.time.ZoneOffset.UTC
import java.time.temporal.ChronoUnit
import java.util.concurrent.TimeoutException
import kotlin.test.Test

/**
 * The expected outputs are generated by copilot.
 */
internal class LinuxNetworkControllerTest {

    @Nested
    inner class RestartAsyncTests {

        @Test
        fun `throws exception if it's not possible to find an active device`() {
            runBlocking {
                // given
                val clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)

                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String = EMPTY
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                )

                // when
                val result = exceptionExpected<IllegalStateException> {
                    linuxNetworkController.restartAsync().await()
                }

                // then
                assertThat(result).hasMessage("Unable to find active network device.")
            }
        }

        @Test
        fun `successfully restart the network controller`() {
            runBlocking {
                // given
                var clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)

                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                val invocations = mutableListOf<List<String>>()
                var numberOfChecks = 0
                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        invocations.add(command)
                        clock = Clock.fixed(clock.instant().plus(1, ChronoUnit.MINUTES), UTC)

                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> {
                                numberOfChecks++

                                when {
                                    numberOfChecks < 3 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    numberOfChecks == 3 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                    numberOfChecks in 4..6 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                    numberOfChecks == 7 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    else -> shouldNotBeInvoked()
                                }
                            }
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                )

                // when
                val result = linuxNetworkController.restartAsync().await()

                // then
                assertThat(result).isTrue()
                assertThat(invocations).containsExactly(
                    listOf("ifconfig"),
                    listOf("sudo", "ifconfig", "en1", "down"),
                    listOf("ifconfig", "en1"),
                    listOf("ifconfig", "en1"),
                    listOf("ifconfig", "en1"),
                    listOf("sudo", "ifconfig", "en1", "up"),
                    listOf("ifconfig", "en1"),
                    listOf("ifconfig", "en1"),
                    listOf("ifconfig", "en1"),
                    listOf("ifconfig", "en1"),
                )
            }
        }

        @Test
        fun `throws exception if timeout hits while waiting for device changing status`() {
            runBlocking {
                // given
                var clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)

                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        clock = Clock.fixed(clock.instant().plus(1, ChronoUnit.MINUTES), UTC)

                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                    timeout = 1,
                )

                // when
                val result =  exceptionExpected<TimeoutException> {
                    linuxNetworkController.restartAsync().await()
                }

                // then
                assertThat(result).hasMessage("Timed out waiting waiting for device to change status.")
            }
        }

        @Test
        fun `throws exception if there are more than maxNumberOfRestarts within timeRangeForMaxRestarts`() {
            runBlocking {
                // given
                var clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)
                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                var numberOfChecks = 0
                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        clock = Clock.fixed(clock.instant().plus(35, ChronoUnit.SECONDS), UTC)

                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> {
                                numberOfChecks++

                                when {
                                    numberOfChecks.mod(2) == 0 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    else -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                }
                            }
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                    timeRangeForMaxRestarts = 3600,
                    maxNumberOfRestarts = 15,
                )
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()

                // when
                val result = exceptionExpected<TooManyRestartsException> {
                    linuxNetworkController.restartAsync().await()
                }

                // then
                assertThat(result).hasMessage("Triggered more than [15] restarts within [3600] seconds.")
            }
        }

        @Test
        fun `successfully surpasses maxNumberOfRestarts if they are executed in a longer time frame than timeRangeForMaxRestarts`() {
            runBlocking {
                // given
                var clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)
                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                var numberOfChecks = 0
                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        clock = Clock.fixed(clock.instant().plus(2, ChronoUnit.MINUTES), UTC)

                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> {
                                numberOfChecks++

                                when {
                                    numberOfChecks.mod(2) == 0 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    else -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                }
                            }
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                    timeRangeForMaxRestarts = 120,
                    maxNumberOfRestarts = 15,
                )
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()
                linuxNetworkController.restartAsync().await()

                // when
                val result = linuxNetworkController.restartAsync().await()

                // then
                assertThat(result).isTrue()
            }
        }

        @Test
        fun `ignores restart if the last restart occured not even a minute ago`() {
            runBlocking {
                // given
                val clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)

                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                val invocations = mutableListOf<List<String>>()
                var numberOfChecks = 0
                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        invocations.add(command)
                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> {
                                numberOfChecks++

                                when {
                                    numberOfChecks < 3 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    numberOfChecks == 3 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                    numberOfChecks in 4..6 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                                    numberOfChecks == 7 -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                                    else -> shouldNotBeInvoked()
                                }
                            }
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                )
                linuxNetworkController.restartAsync().await()

                // when
                val result = linuxNetworkController.restartAsync().await()

                // then
                assertThat(result).isFalse()
            }
        }
    }

    @Nested
    inner class IsNetworkActiveTests {

        @Test
        fun `return true of it's active`() {
            runBlocking {
                // given
                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = TestCommandExecutor,
                )

                // when
                val result = linuxNetworkController.isNetworkActive()

                // then
                assertThat(result).isTrue()
            }
        }

        @Test
        @OptIn(DelicateCoroutinesApi::class)
        fun `return false it's inactive`() {
            runBlocking {
                // given
                var clock = Clock.fixed(Instant.parse("2021-01-31T16:02:42.00Z"), UTC)

                val testAppConfig = object: Config by TestAppConfig {
                    override fun isTestContext(): Boolean = true
                    override fun clock(): Clock = clock
                }

                val testCommandExecutor = object : CommandExecutor {
                    override var config: CommandLineConfig = CommandLineConfig()
                    override fun executeCmd(command: List<String>): String {
                        clock = Clock.fixed(clock.instant().plus(1, ChronoUnit.SECONDS), UTC)
                        return when {
                            command.containsExactlyInTheSameOrder(listOf("ifconfig")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/all_devices.txt")
                            command.containsExactlyInTheSameOrder(listOf("ifconfig", "en1")) -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("up") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_down.txt")
                            command.any { it.contains("down") } -> loadTestResource<String>("network/LinuxNetworkControllerTest/device_up.txt")
                            else -> shouldNotBeInvoked()
                        }
                    }
                }

                val linuxNetworkController = LinuxNetworkController(
                    appConfig = testAppConfig,
                    kotlinCommandExecutor = testCommandExecutor,
                )

                GlobalScope.launch {
                    linuxNetworkController.restartAsync().start()
                }

                delay(100)

                // when
                val result = linuxNetworkController.isNetworkActive()

                // then
                assertThat(result).isFalse()
            }
        }
    }

    @Nested
    inner class CompanionObjectTests {

        @Test
        fun `instance property always returns same instance`() {
            tempDirectory {
                // given
                val previous = LinuxNetworkController.instance

                // when
                val result = LinuxNetworkController.instance

                // then
                assertThat(result).isExactlyInstanceOf(LinuxNetworkController::class.java)
                assertThat(result===previous).isTrue()
            }
        }
    }
}